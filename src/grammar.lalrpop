use crate::frontend::ast::{Expr, Opcode, Literal, Stmt, ExprNode, Type};
use std::str::FromStr;

grammar;

pub Stmts: Vec<Box<Stmt>> = {
    Stmt*,
}

// Comma Macro

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

// Nonterminal Symbols - Statements

Stmt: Box<Stmt> = {
    <decl:DeclStmt> ";" => decl,
    <assign:AssignStmt> ";" => assign,
    "while" <cond:Expr> "{" <stmts:Stmts> "}" => Box::new(Stmt::While(cond, Box::new(Stmt::Block(stmts)))),
    "if" <cond:Expr> "{" <stmts:Stmts> "}" => {
        Box::new(Stmt::If(cond,
            Box::new(Stmt::Block(stmts)),
            Box::new(Stmt::Block(Vec::new()))))},
    // TODO: Synthesize while loop from for loop
    "for" <init:DeclStmt?> ";" <test:Expr?> ";" <increment:AssignStmt?> ";" "{" <body:Stmts> "}" => {
        Box::new(Stmt::For(init, test, increment,
            Box::new(Stmt::Block(body))))},
    "fun" <name:IdentifierName> "(" <params:Comma<Expr>> ")" "->" <ret:Type> "{" <body:Stmts> "}" => {
        Box::new(Stmt::FunDecl(
            name,
            params,
            ret,
            Box::new(Stmt::Block(body))))},
    "fun" <name:IdentifierName> "(" <params:Comma<Expr>> ")" "{" <body:Stmts> "}" => {
        Box::new(Stmt::FunDecl(
            name,
            params,
            Type::Nil,
    Box::new(Stmt::Block(body))))},
    "return" <value:Expr?> ";" => Box::new(Stmt::Return(value)),
    <proc:FuncExpr> ";" => Box::new(Stmt::Assignment(ExprNode::new_nil(), proc)),
};

DeclStmt: Box<Stmt> = {
    "var" <id:Identifier> "=" <rhs:Expr> => Box::new(Stmt::Declaration(id.identify(), rhs)),
    "var" <id:Identifier> => Box::new(Stmt::Declaration(id.identify(), ExprNode::new_typed(Expr::Literal(Literal::Nil), id.type_of))),
}

AssignStmt: Box<Stmt> = {
    <lhs:Expr> "=" <rhs:Expr> => Box::new(Stmt::Assignment(lhs, rhs)),
};

// Nonterminal Symbols - Expressions

Expr: ExprNode = {
    LogicalExpr,
};

LogicalExpr: ExprNode = {
    LogicalExpr LogicalOp EqualityExpr => ExprNode::new_untyped(Expr::BinaryOp(<>)),
    EqualityExpr,
};

EqualityExpr: ExprNode = {
    EqualityExpr EqualityOp CompareExpr => ExprNode::new_untyped(Expr::BinaryOp(<>)),
    CompareExpr,
};

CompareExpr: ExprNode = {
    CompareExpr CompareOp AddExpr => ExprNode::new_untyped(Expr::BinaryOp(<>)),
    AddExpr,
};

AddExpr: ExprNode = {
    AddExpr AddOp MultExpr => ExprNode::new_untyped(Expr::BinaryOp(<>)),
    MultExpr,
};

MultExpr: ExprNode = {
    MultExpr MultOp UnaryExpr => ExprNode::new_untyped(Expr::BinaryOp(<>)),
    UnaryExpr,
};

UnaryExpr: ExprNode = {
    UnaryOp UnaryExpr => ExprNode::new_untyped(Expr::UnaryOp(<>)),
    FuncHandler
};

FuncHandler: ExprNode = {
    FuncExpr,
    PrimaryExpr
}

FuncExpr: ExprNode = {
    <name:IdentifierName> "(" <params:Comma<Expr>> ")" => ExprNode::new_untyped(Expr::FunCall(name, params)),
}

PrimaryExpr: ExprNode = {
    Num => ExprNode::new_typed(Expr::Literal(Literal::Number(<>)), Type::Number),
    Bool => ExprNode::new_typed(Expr::Literal(Literal::Boolean(<>)), Type::Boolean),
    String => ExprNode::new_typed(Expr::Literal(Literal::String(<>)), Type::String),
    "(" <Expr> ")",
    "Nil" => ExprNode::new_untyped(Expr::Literal(Literal::Nil)),
//    Identifier => ExprNode::new_untyped(Expr::Identifier(<>)),
    Identifier,
};

// Terminal Symbols

Type: Type = {
    "nil" => Type::Nil,
    "num" => Type::Number,
    "bool" => Type::Boolean,
    "str" => Type::String,
}

Identifier: ExprNode = {
    <id:IdentifierName> ":" <t:Type> => ExprNode::new_typed(Expr::Identifier(id), t),
    <id:IdentifierName> => ExprNode::new_untyped(Expr::Identifier(id)),
}

IdentifierName: String = {
    r#"[[:alpha:]]\w*"# => String::from(<>),
};

String: String = {
    r#""[^"]*""# => String::from(<>),
};

Bool: bool = {
    "True" => true,
    "False" => false,
};

Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap(),
};

LogicalOp: Opcode = {
    "and" => Opcode::And,
    "or" => Opcode::Or,
};

EqualityOp: Opcode = {
    "==" => Opcode::EqualEqual,
    "!=" => Opcode::BangEqual,
};

CompareOp: Opcode = {
    "<" => Opcode::Lesser,
    ">" => Opcode::Greater,
    "<=" => Opcode::LesserEqual,
    ">=" => Opcode::GreaterEqual,
};

MultOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

AddOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

UnaryOp: Opcode = {
    "not" => Opcode::Not,
    "-" => Opcode::Sub,
};

